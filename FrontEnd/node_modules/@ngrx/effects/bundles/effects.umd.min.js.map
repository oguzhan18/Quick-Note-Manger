{"version":3,"sources":["../../../modules/effects/src/effects_metadata.ts","../../../modules/effects/src/on_run_effects.ts","../../../modules/effects/src/effects_resolver.ts","../../../modules/effects/src/effect_notification.ts","../../../modules/effects/src/effects_module.ts","../../../modules/effects/src/util.ts","../../../modules/effects/src/actions.ts","../../../modules/effects/src/tokens.ts","../../../modules/effects/src/error_reporter.ts","../../../modules/effects/src/effect_sources.ts","../../../modules/effects/src/effects_runner.ts","../../../modules/effects/src/effects_root_module.ts","../../../modules/effects/src/effects_feature_module.ts"],"names":["getEffectMetadataEntries","sourceProto","constructor","METADATA_KEY","setEffectMetadataEntries","entries","meta","hasOwnProperty","Object","defineProperty","value","Array","prototype","push","apply","Effect","_a","dispatch","target","propertyName","getSourceForInstance","instance","getPrototypeOf","getEffectsMetadata","metadata","getSourceMetadata","forEach","isOnRunEffects","sourceInstance","source","onRunEffectsKey","mergeEffects","sourceName","name","observables","map","observable","ignoreElements","call","materialized$","materialize","notification","effect","merge","resolveEffectSource","mergedEffects$","ngrxOnRunEffects","verifyOutput","output","reporter","reportErrorThrown","reportInvalidActions","kind","errorReason","getEffectName","report","Source","Error","error","Notification","action","isAction","Dispatched","type","createSourceInstances","instances","_i","arguments","length","getConsole","console","toPayload","payload","compose","Actions","_super","_this","this","Observable","lift","operator","ofType","allowedTypes","filter","some","decorators","Injectable","ctorParameters","Inject","args","ScannedActionsSubject","ROOT_EFFECTS","InjectionToken","FEATURE_EFFECTS","CONSOLE","ErrorReporter","reason","details","group","key","groupEnd","undefined","EffectSources","errorReporter","Subject","addEffects","effectSourceInstance","next","toActions","mergeMap","groupBy","source$","dematerialize","exhaustMap","EffectsRunner","effectSources","store","effectsSubscription","start","subscribe","ngOnDestroy","unsubscribe","Store","ROOT_EFFECTS_INIT","EffectsRootModule","sources","runner","rootEffects","storeModule","NgModule","StoreModule","Optional","EffectsFeatureModule","root","effectSourceGroups","EffectsModule","forFeature","featureEffects","ngModule","providers","provide","multi","deps","useFactory","forRoot"],"mappings":"+lCAgBA,SAAAA,GAHCC,GAIC,MAHOA,GAAYC,YAAYC,OAUjC,QAAAC,GAPCH,EAAAI,GAQC,GAPMH,GAAcD,EAAYC,YAC1BI,EAAyBJ,EAAYK,eAAeJ,GACtD,EAAqBA,GACrBK,OAAOC,eAAeP,EAAaC,GAAgBO,WAQjDP,EAENQ,OAPMC,UAAUC,KAAKC,MAAMR,EAAMD,GAanC,QAAAU,GAVCC,GAAD,GAACC,QAAD,KAAAD,GAAAC,UAAA,GAAAD,GAAAC,QAWE,OAVO,UAAAC,EAAsBC,GAY3Bf,EAVyBc,IADUC,aAUvCA,EAVqDF,SAUrDA,MAQA,QAAAG,GAbCC,GAcC,MAbOb,QAAOc,eAAeD,GAiC/B,QAAAE,GAjBCF,GAkBC,GAjBMG,KAuBN,OAJAC,GAjBkBJ,GAAUK,QAAQ,SAACV,GAAvC,GAAyCG,GAAzCH,EAAAG,aAAuDF,EAAvDD,EAAAC,QAkBIO,GAjBSL,IAAkBF,SAiB/BA,KAdSO,EC3CT,QAAAG,GACEC,GAEA,GAHMC,GAAST,EAAqBQ,EAKpC,OACEE,KAHmBD,IAA6C,kBAA5BA,GAAOC,GCJ/C,QAAAC,GACEH,GAEA,GAHMI,GAAaZ,EAAqBQ,GAAgB1B,YAAY+B,KAE9DC,EAAiCT,EAIrCG,GAFAO,IAAI,SAACnB,GAAT,GAAWG,GAAXH,EAAAG,aAAyBF,EAAzBD,EAAAC,SACUmB,EACoC,kBAAjCR,GAAeT,GAClBS,EAAeT,KACfS,EAAeT,EAKrB,KAHiB,IAGbF,EACF,MAHOoB,GAAAA,eAAeC,KAAKF,EAM7B,IAHMG,GAAgBC,EAAAA,YAAYF,KAAKF,EAKvC,OAHOD,GAAAA,IAAIG,KAITC,EACA,SAACE,GAFP,OAGQC,OAHQd,EAAeT,GAIvBsB,aAARA,EACQtB,aAARA,EACQa,WAARA,EACQJ,eAARA,MAKE,OAHOe,GAAAA,MAGT7B,UAAA,GAHgBoB,GAShB,QAAAU,GANChB,GAOC,GANMiB,GAAiBd,EAAaH,EAQpC,OAAID,GANeC,GACVA,EAAekB,iBAAiBD,GAGlCA,ECnCT,QAAAE,GACEC,EACAC,GAEAC,EAJkBF,EAAQC,GAK1BE,EAJqBH,EAAQC,GAW/B,QAAAC,GACEF,EACAC,GAEA,GARiC,MAQ7BD,EAROP,aAAaW,KAAc,CASpC,GARMC,GAAc,UAAAC,EAAwBN,GAQhD,iBAEIC,GARSM,OAAOF,GASdG,OARQR,EAAOpB,eASfb,OARQiC,EAAON,OASfe,MAROT,EAAOP,aAAaiB,MAS3BC,aARcX,EAAOP,gBAiB3B,QAAAU,GACEH,EACAC,GAEA,GAZiC,MAY7BD,EAZOP,aAAaW,KAAc,CAapC,GAZMQ,GAASZ,EAAOP,aAAa/B,KAenC,KAdwBmD,EAAUD,GAEb,CAanB,GAZMP,GAAc,UAAAC,EAalBN,GADR,+BAIMC,GAZSM,OAAOF,GAadG,OAZQR,EAAOpB,eAafb,OAZQiC,EAAON,OAafoB,WAZYF,EAaZD,aAZcX,EAAOP,iBAqB7B,QAAAoB,GAfCD,GAgBC,MAfOA,IAAUA,EAAOG,MAA+B,gBAAhBH,GAAOG,KAqBhD,QAAAT,GAlBCtC,GAmBD,GAAEG,GAAFH,EAAAG,aACES,EADFZ,EAAAY,cAME,OAlBO,IAYTZ,EAAAgB,WAMA,IAlBwBb,GAFmC,kBAAjCS,GAAeT,GAEY,KAAO,IAkB5D,ICbA,QAAA6C,KArBA,IAAC,GAADC,MAAAC,EAAA,EAACA,EAADC,UAAAC,OAACF,IAAAD,EAADC,GAAAC,UAAAD,EAsBE,OA3BOD,GAgCT,QAAAI,KACE,MA7BOC,SChDT,QAAAC,GADCX,GAEC,MADO,GAAgBY,yTLDnBrE,EAAe,oBAiCRsB,EAAoBgD,EAAAA,QAc/BzE,EACAoB,GC3CIU,EAAsC,mBKL5C4C,EAAA,SAAAC,GAIA,QAAAD,GADe7C,GACf,GAAA+C,GACID,EADJrC,KAAAuC,OAAAA,WAGQhD,KACF+C,EAAK/C,OAASA,WANnBiD,GAADA,EAAAA,GAcAJ,EAAA9D,UAAAmE,KAAA,SALGC,GAMC,GALM5C,GAAa,GAAIsC,EAQvB,OAFAtC,GALWP,OAASgD,KAMpBzC,EALW4C,SAAWA,EACf5C,GAYXsC,EAAA9D,UAAAqE,OAAA,WATA,IAAG,GAAHC,MAAAhB,EAAA,EAAGA,EAAHC,UAAAC,OAAGF,IAAAgB,EAAHhB,GAAAC,UAAAD,EAUI,OATOiB,GAAAA,OAAO7C,KAAKuC,KAAM,SAAAjB,GAUvB,MAAAsB,GATaE,KAAK,SAAArB,GAAQ,MAAAA,KAASH,EAAOG,aAlB/Ce,EAAAA,WAqBMJ,GAAPW,aACEtB,KAAMuB,EAAAA,aAGPZ,EAADa,eAAC,WAAA,QAYAxB,KAAMe,EAAAA,WAAYO,aAAetB,KAAMyB,EAAAA,OAAQC,MAAOC,EAAAA,2BC1ChD,IAGMC,IAHoB,GAAIC,GAAAA,eACnC,mCAE0B,GAAIA,GAAAA,eAC9B,+BAEWC,EAAkB,GAAID,GAAAA,eACjC,iCAEWE,EAAU,GAAIF,GAAAA,eAAuB,mBCTlDG,EAAA,WAIA,QAAAA,GADuBzB,GAAAO,KAAvBP,QAAuBA,QAQvByB,GAAAnF,UAAA2C,OAAA,SANGyC,EAAAC,GAOCpB,KANKP,QAAQ4B,MAAMF,EAQnB,KAAK,GANIG,KAAOF,GAOdpB,KANKP,QAAQZ,MAAOyC,EAM1B,IANoCF,EAAQE,GASxCtB,MANKP,QAAQ8B,gBAEVL,GAAPV,aACEtB,KAAMuB,EAAAA,aAGPS,EAADR,eAAC,WAAA,QASAxB,SAAMsC,GAAWhB,aAAetB,KAAMyB,EAAAA,OAAQC,MAAOK,OCbtD,IAAAQ,GAAA,SAAA3B,GAIA,QAAA2B,GADsBC,GACtB,GAAA3B,GACID,EADJrC,KAAAuC,OAAAA,WADsBD,GAAtB2B,cAAsBA,UADrBC,GAADA,EAAAA,GASAF,EAAA1F,UAAA6F,WAAA,SAJGC,GAKC7B,KAJK8B,KAAKD,IASdJ,EAAA1F,UAAAgG,UAAA,WAAA,GAAAhC,GAAAC,IACI,OAHOgC,GAAAA,SAASvE,KAIdwE,EAAAA,QAHQxE,KAAKuC,KAAMzD,GAInB,SAAC2F,GACCC,MAAAA,GAAAA,cAHc1E,KAIZ6C,EAAAA,OAHO7C,KAILH,EAAAA,IAHIG,KAIF2E,EAAAA,WAHW3E,KAAKyE,EAASnE,GAIzB,SAACI,GAGC,MAFAD,GAHaC,EAAQ4B,EAAK2B,eAEnBvD,EAAOP,eAMlB,SAACA,GAHoC,MAAsB,MAAtBA,EAAaW,cA1B7DoD,EAAAA,QA+BMF,GAAPjB,aACEtB,KAAMuB,EAAAA,aAGPgB,EAADf,eAAC,WAAA,QAMAxB,KAAMgC,ICvDP,IAAAmB,GAAA,WAMA,QAAAA,GAAYC,EACAC,GADAvC,KAAZsC,cAAYA,EACAtC,KAAZuC,MAAYA,EAJFvC,KAAVwC,oBAAqD,WAUrDH,GAAAtG,UAAA0G,MAAA,WAFSzC,KAAKwC,sBAIRxC,KAHKwC,oBAAsBxC,KAAKsC,cAI7BP,YACAW,UAHU1C,KAAKuC,SASxBF,EAAAtG,UAAA4G,YAAA,WACQ3C,KALKwC,sBAMPxC,KALKwC,oBAAoBI,cAMzB5C,KALKwC,oBAAsB,WAG1BH,GAAP7B,aACEtB,KAAMuB,EAAAA,aAGP4B,EAAD3B,eAAC,WAAA,QAQAxB,KAAMuC,IACNvC,KAAM2D,EAAAA,QCnCA,IAAMC,GAAoB,qBACjCC,EAAA,WAQA,QAAAA,GAJYC,EAMRC,EACAV,EACCW,EACAC,GATOnD,KAAZgD,QAAYA,EAWRC,EAAOR,QAEPS,EAAYrG,QAAQ,SAAAgF,GAClB,MAAAmB,GAAQpB,WAAWC,KAGrBU,EAAMnG,UAAW8C,KAAM4D,UAM3BC,GAAAhH,UAAA6F,WAAA,SARGC,GASC7B,KARKgD,QAAQpB,WAAWC,QAErBkB,GAAPvC,aACEtB,KAAMkE,EAAAA,SAAUxC,YAGjBmC,EAADrC,eAAC,WAAA,QAWAxB,KAAMuC,IACNvC,KAAMmD,IACNnD,KAAM2D,EAAAA,QACN3D,KAAMpD,MAAO0E,aAAetB,KAAMyB,EAAAA,OAAQC,MAAOE,OACjD5B,KAAMmE,EAAAA,YAAa7C,aAAetB,KAAMoE,EAAAA,aC5CzC,IAAAC,GAAA,WAMA,QAAAA,GAFYC,EAIPC,EACAN,GALOnD,KAAZwD,KAAYA,EAORC,EAAmB5G,QAAQ,SAAAwE,GACzB,MAAAA,GAAMxE,QAAQ,SAAAgF,GACZ,MAAA2B,GAAK5B,WAAWC,kBACjB0B,GAAP/C,aACEtB,KAAMkE,EAAAA,SAAUxC,YAGjB2C,EAAD7C,eAAC,WAAA,QAMAxB,KAAM6D,IACN7D,KAAMpD,MAAO0E,aAAetB,KAAMyB,EAAAA,OAAQC,MAAOI,OACjD9B,KAAMmE,EAAAA,YAAa7C,aAAetB,KAAMoE,EAAAA,aRtBzC,IAAAI,GAAA,WAAA,QAAAA,YAGGA,GAAHC,WAEA,SAFGC,GAGC,OACEC,SAFUN,EAGVO,WACEF,GAEEG,QAFS/C,EAGTgD,OAFO,EAGPC,KAFML,EAGNM,WAFY/E,MAMnBuE,EAAHS,QAKA,SALGjB,GAMC,OACEW,SALUd,EAMVe,WACEzB,EACAZ,EACAP,EACArB,EACAqD,GAEEa,QALSjD,EAMTmD,KALMf,EAMNgB,WALY/E,IAQZ4E,QALS9C,EAMTiD,WALY1E,UAKfkE,GAAPlD,aACEtB,KAAMkE,EAAAA,SAAUxC,YAGjB8C,EAADhD,eAAC,WAAA","file":"./dist/effects/bundles/effects.umd.min.js","sourcesContent":["import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { Observable } from 'rxjs/Observable';\nimport { compose } from '@ngrx/store';\n\nconst /** @type {?} */ METADATA_KEY = '__@ngrx/effects__';\nconst /** @type {?} */ r: any = Reflect;\n\nexport interface EffectMetadata {\n  propertyName: string;\n  dispatch: boolean;\n}\n/**\n * @param {?} sourceProto\n * @return {?}\n */\nfunction getEffectMetadataEntries(sourceProto: any): EffectMetadata[] {\n  return sourceProto.constructor[METADATA_KEY] || [];\n}\n/**\n * @param {?} sourceProto\n * @param {?} entries\n * @return {?}\n */\nfunction setEffectMetadataEntries(sourceProto: any, entries: EffectMetadata[]) {\n  const /** @type {?} */ constructor = sourceProto.constructor;\n  const /** @type {?} */ meta: EffectMetadata[] = constructor.hasOwnProperty(METADATA_KEY)\n    ? ( /** @type {?} */((constructor as any)))[METADATA_KEY]\n    : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[\n        METADATA_KEY\n      ];\n  Array.prototype.push.apply(meta, entries);\n}\n/**\n * @param {?=} __0\n * @return {?}\n */\nexport function Effect({ dispatch } = { dispatch: true }): PropertyDecorator {\n  return function(target: any, propertyName: string) {\n    const /** @type {?} */ metadata: EffectMetadata = { propertyName, dispatch };\n    setEffectMetadataEntries(target, [metadata]);\n  };\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function getSourceForInstance(instance: Object): any {\n  return Object.getPrototypeOf(instance);\n}\n\nexport const /** @type {?} */ getSourceMetadata = compose(\n  getEffectMetadataEntries,\n  getSourceForInstance\n);\n\nexport type EffectsMetadata<T> = {\n  [key in keyof T]?:\n    | undefined\n    | {\n        dispatch: boolean;\n      }\n};\n/**\n * @template T\n * @param {?} instance\n * @return {?}\n */\nexport function getEffectsMetadata<T>(instance: T): EffectsMetadata<T> {\n  const /** @type {?} */ metadata: EffectsMetadata<T> = {};\n\n  getSourceMetadata(instance).forEach(({ propertyName, dispatch }) => {\n    metadata[propertyName] = { dispatch };\n  });\n\n  return metadata;\n}\n","import { Observable } from 'rxjs/Observable';\nimport { getSourceForInstance } from './effects_metadata';\nimport { EffectNotification } from './effect_notification';\n\nexport interface OnRunEffects {\n  ngrxOnRunEffects(\n    resolvedEffects$: Observable<EffectNotification>\n  ): Observable<EffectNotification>;\n}\n\nconst /** @type {?} */ onRunEffectsKey: keyof OnRunEffects = 'ngrxOnRunEffects';\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nexport function isOnRunEffects(\n  sourceInstance: Object\n): sourceInstance is OnRunEffects {\n  const /** @type {?} */ source = getSourceForInstance(sourceInstance);\n\n  return (\n    onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function'\n  );\n}\n","import { merge } from 'rxjs/observable/merge';\nimport { ignoreElements } from 'rxjs/operator/ignoreElements';\nimport { materialize } from 'rxjs/operator/materialize';\nimport { map } from 'rxjs/operator/map';\nimport { Observable } from 'rxjs/Observable';\nimport { Notification } from 'rxjs/Notification';\nimport { Action } from '@ngrx/store';\nimport { EffectNotification } from './effect_notification';\nimport { getSourceMetadata, getSourceForInstance } from './effects_metadata';\nimport { isOnRunEffects } from './on_run_effects';\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nexport function mergeEffects(\n  sourceInstance: any\n): Observable<EffectNotification> {\n  const /** @type {?} */ sourceName = getSourceForInstance(sourceInstance).constructor.name;\n\n  const /** @type {?} */ observables: Observable<any>[] = getSourceMetadata(\n    sourceInstance\n  ).map(({ propertyName, dispatch }): Observable<EffectNotification> => {\n    const /** @type {?} */ observable: Observable<any> =\n      typeof sourceInstance[propertyName] === 'function'\n        ? sourceInstance[propertyName]()\n        : sourceInstance[propertyName];\n\n    if (dispatch === false) {\n      return ignoreElements.call(observable);\n    }\n\n    const /** @type {?} */ materialized$ = materialize.call(observable);\n\n    return map.call(\n      materialized$,\n      (notification: Notification<Action>): EffectNotification => ({\n        effect: sourceInstance[propertyName],\n        notification,\n        propertyName,\n        sourceName,\n        sourceInstance,\n      })\n    );\n  });\n\n  return merge(...observables);\n}\n/**\n * @param {?} sourceInstance\n * @return {?}\n */\nexport function resolveEffectSource(sourceInstance: any) {\n  const /** @type {?} */ mergedEffects$ = mergeEffects(sourceInstance);\n\n  if (isOnRunEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n  }\n\n  return mergedEffects$;\n}\n","import { Observable } from 'rxjs/Observable';\nimport { Notification } from 'rxjs/Notification';\nimport { Action } from '@ngrx/store';\nimport { ErrorReporter } from './error_reporter';\n\nexport interface EffectNotification {\n  effect: Observable<any> | (() => Observable<any>);\n  propertyName: string;\n  sourceName: string;\n  sourceInstance: any;\n  notification: Notification<Action | null | undefined>;\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nexport function verifyOutput(\n  output: EffectNotification,\n  reporter: ErrorReporter\n) {\n  reportErrorThrown(output, reporter);\n  reportInvalidActions(output, reporter);\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportErrorThrown(\n  output: EffectNotification,\n  reporter: ErrorReporter\n) {\n  if (output.notification.kind === 'E') {\n    const /** @type {?} */ errorReason = `Effect ${getEffectName(output)} threw an error`;\n\n    reporter.report(errorReason, {\n      Source: output.sourceInstance,\n      Effect: output.effect,\n      Error: output.notification.error,\n      Notification: output.notification,\n    });\n  }\n}\n/**\n * @param {?} output\n * @param {?} reporter\n * @return {?}\n */\nfunction reportInvalidActions(\n  output: EffectNotification,\n  reporter: ErrorReporter\n) {\n  if (output.notification.kind === 'N') {\n    const /** @type {?} */ action = output.notification.value;\n    const /** @type {?} */ isInvalidAction = !isAction(action);\n\n    if (isInvalidAction) {\n      const /** @type {?} */ errorReason = `Effect ${getEffectName(\n        output\n      )} dispatched an invalid action`;\n\n      reporter.report(errorReason, {\n        Source: output.sourceInstance,\n        Effect: output.effect,\n        Dispatched: action,\n        Notification: output.notification,\n      });\n    }\n  }\n}\n/**\n * @param {?} action\n * @return {?}\n */\nfunction isAction(action: any): action is Action {\n  return action && action.type && typeof action.type === 'string';\n}\n/**\n * @param {?} __0\n * @return {?}\n */\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName,\n}: EffectNotification) {\n  const /** @type {?} */ isMethod = typeof sourceInstance[propertyName] === 'function';\n\n  return `\"${sourceName}.${propertyName}${isMethod ? '()' : ''}\"`;\n}\n","import { NgModule, ModuleWithProviders, Type } from '@angular/core';\nimport { EffectSources } from './effect_sources';\nimport { Actions } from './actions';\nimport { ROOT_EFFECTS, FEATURE_EFFECTS, CONSOLE } from './tokens';\nimport { EffectsFeatureModule } from './effects_feature_module';\nimport { EffectsRootModule } from './effects_root_module';\nimport { EffectsRunner } from './effects_runner';\nimport { ErrorReporter } from './error_reporter';\nexport class EffectsModule {\n/**\n * @param {?} featureEffects\n * @return {?}\n */\nstatic forFeature(featureEffects: Type<any>[]): ModuleWithProviders {\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [\n        featureEffects,\n        {\n          provide: FEATURE_EFFECTS,\n          multi: true,\n          deps: featureEffects,\n          useFactory: createSourceInstances,\n        },\n      ],\n    };\n  }\n/**\n * @param {?} rootEffects\n * @return {?}\n */\nstatic forRoot(rootEffects: Type<any>[]): ModuleWithProviders {\n    return {\n      ngModule: EffectsRootModule,\n      providers: [\n        EffectsRunner,\n        EffectSources,\n        ErrorReporter,\n        Actions,\n        rootEffects,\n        {\n          provide: ROOT_EFFECTS,\n          deps: rootEffects,\n          useFactory: createSourceInstances,\n        },\n        {\n          provide: CONSOLE,\n          useFactory: getConsole,\n        },\n      ],\n    };\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\nfunction EffectsModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsModule.ctorParameters;\n}\n\n/**\n * @param {...?} instances\n * @return {?}\n */\nexport function createSourceInstances(...instances: any[]) {\n  return instances;\n}\n/**\n * @return {?}\n */\nexport function getConsole() {\n  return console;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Action } from '@ngrx/store';\n/**\n * @deprecated Since version 4.1. Will be deleted in version 5.0.\n * @param {?} action\n * @return {?}\n */\nexport function toPayload(action: Action): any {\n  return ( /** @type {?} */((action as any))).payload;\n}\n","import { Injectable, Inject } from '@angular/core';\nimport { Action, ScannedActionsSubject } from '@ngrx/store';\nimport { Observable } from 'rxjs/Observable';\nimport { Operator } from 'rxjs/Operator';\nimport { filter } from 'rxjs/operator/filter';\nexport class Actions<V = Action> extends Observable<V> {\n/**\n * @param {?=} source\n */\nconstructor( source?: Observable<V>) {\n    super();\n\n    if (source) {\n      this.source = source;\n    }\n  }\n/**\n * @template R\n * @param {?} operator\n * @return {?}\n */\nlift<R>(operator: Operator<V, R>): Observable<R> {\n    const /** @type {?} */ observable = new Actions<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n/**\n * @template V2\n * @param {...?} allowedTypes\n * @return {?}\n */\nofType<V2 extends V = V>(...allowedTypes: string[]): Actions<V2> {\n    return filter.call(this, (action: Action) =>\n      allowedTypes.some(type => type === action.type)\n    );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Observable, decorators: [{ type: Inject, args: [ScannedActionsSubject, ] }, ]},\n];\n}\n\nfunction Actions_tsickle_Closure_declarations() {\n/** @type {?} */\nActions.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nActions.ctorParameters;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { InjectionToken, Type } from '@angular/core';\n\nexport const /** @type {?} */ IMMEDIATE_EFFECTS = new InjectionToken<any[]>(\n  'ngrx/effects: Immediate Effects'\n);\nexport const /** @type {?} */ ROOT_EFFECTS = new InjectionToken<Type<any>[]>(\n  'ngrx/effects: Root Effects'\n);\nexport const /** @type {?} */ FEATURE_EFFECTS = new InjectionToken<any[][]>(\n  'ngrx/effects: Feature Effects'\n);\nexport const /** @type {?} */ CONSOLE = new InjectionToken<Console>('Browser Console');\n","import { Injectable, InjectionToken, Inject } from '@angular/core';\nimport { CONSOLE } from './tokens';\nexport class ErrorReporter {\n/**\n * @param {?} console\n */\nconstructor(\nprivate console: any) {}\n/**\n * @param {?} reason\n * @param {?} details\n * @return {?}\n */\nreport(reason: string, details: any): void {\n    this.console.group(reason);\n\n    for (let /** @type {?} */ key in details) {\n      this.console.error(`${key}:`, details[key]);\n    }\n\n    this.console.groupEnd();\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [CONSOLE, ] }, ]},\n];\n}\n\nfunction ErrorReporter_tsickle_Closure_declarations() {\n/** @type {?} */\nErrorReporter.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nErrorReporter.ctorParameters;\n/** @type {?} */\nErrorReporter.prototype.console;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { groupBy, GroupedObservable } from 'rxjs/operator/groupBy';\nimport { mergeMap } from 'rxjs/operator/mergeMap';\nimport { exhaustMap } from 'rxjs/operator/exhaustMap';\nimport { map } from 'rxjs/operator/map';\nimport { dematerialize } from 'rxjs/operator/dematerialize';\nimport { filter } from 'rxjs/operator/filter';\nimport { concat } from 'rxjs/observable/concat';\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { Notification } from 'rxjs/Notification';\nimport { Injectable } from '@angular/core';\nimport { Action } from '@ngrx/store';\nimport { EffectNotification, verifyOutput } from './effect_notification';\nimport { getSourceForInstance } from './effects_metadata';\nimport { resolveEffectSource } from './effects_resolver';\nimport { ErrorReporter } from './error_reporter';\nexport class EffectSources extends Subject<any> {\n/**\n * @param {?} errorReporter\n */\nconstructor(private errorReporter: ErrorReporter) {\n    super();\n  }\n/**\n * @param {?} effectSourceInstance\n * @return {?}\n */\naddEffects(effectSourceInstance: any) {\n    this.next(effectSourceInstance);\n  }\n/**\n * @return {?}\n */\ntoActions(): Observable<Action> {\n    return mergeMap.call(\n      groupBy.call(this, getSourceForInstance),\n      (source$: GroupedObservable<any, any>) =>\n        dematerialize.call(\n          filter.call(\n            map.call(\n              exhaustMap.call(source$, resolveEffectSource),\n              (output: EffectNotification) => {\n                verifyOutput(output, this.errorReporter);\n\n                return output.notification;\n              }\n            ),\n            (notification: Notification<any>) => notification.kind === 'N'\n          )\n        )\n    );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ErrorReporter, },\n];\n}\n\nfunction EffectSources_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectSources.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectSources.ctorParameters;\n/** @type {?} */\nEffectSources.prototype.errorReporter;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { Subscription } from 'rxjs/Subscription';\nimport { Injectable, OnDestroy } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { EffectSources } from './effect_sources';\nexport class EffectsRunner implements OnDestroy {\nprivate effectsSubscription: Subscription | null = null;\n/**\n * @param {?} effectSources\n * @param {?} store\n */\nconstructor(\nprivate effectSources: EffectSources,\nprivate store: Store<any>\n  ) {}\n/**\n * @return {?}\n */\nstart() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources\n        .toActions()\n        .subscribe(this.store);\n    }\n  }\n/**\n * @return {?}\n */\nngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectSources, },\n{type: Store, },\n];\n}\n\nfunction EffectsRunner_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsRunner.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsRunner.ctorParameters;\n/** @type {?} */\nEffectsRunner.prototype.effectsSubscription;\n/** @type {?} */\nEffectsRunner.prototype.effectSources;\n/** @type {?} */\nEffectsRunner.prototype.store;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreModule, Store } from '@ngrx/store';\nimport { EffectsRunner } from './effects_runner';\nimport { EffectSources } from './effect_sources';\nimport { ROOT_EFFECTS } from './tokens';\n\nexport const /** @type {?} */ ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nexport class EffectsRootModule {\n/**\n * @param {?} sources\n * @param {?} runner\n * @param {?} store\n * @param {?} rootEffects\n * @param {?} storeModule\n */\nconstructor(\nprivate sources: EffectSources,\n    runner: EffectsRunner,\n    store: Store<any>,\n     rootEffects: any[],\n     storeModule: StoreModule\n  ) {\n    runner.start();\n\n    rootEffects.forEach(effectSourceInstance =>\n      sources.addEffects(effectSourceInstance)\n    );\n\n    store.dispatch({ type: ROOT_EFFECTS_INIT });\n  }\n/**\n * @param {?} effectSourceInstance\n * @return {?}\n */\naddEffects(effectSourceInstance: any) {\n    this.sources.addEffects(effectSourceInstance);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectSources, },\n{type: EffectsRunner, },\n{type: Store, },\n{type: Array, decorators: [{ type: Inject, args: [ROOT_EFFECTS, ] }, ]},\n{type: StoreModule, decorators: [{ type: Optional }, ]},\n];\n}\n\nfunction EffectsRootModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsRootModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsRootModule.ctorParameters;\n/** @type {?} */\nEffectsRootModule.prototype.sources;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { NgModule, Inject, Optional } from '@angular/core';\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsRootModule } from './effects_root_module';\nimport { FEATURE_EFFECTS } from './tokens';\nexport class EffectsFeatureModule {\n/**\n * @param {?} root\n * @param {?} effectSourceGroups\n * @param {?} storeModule\n */\nconstructor(\nprivate root: EffectsRootModule,\n     effectSourceGroups: any[][],\n     storeModule: StoreModule\n  ) {\n    effectSourceGroups.forEach(group =>\n      group.forEach(effectSourceInstance =>\n        root.addEffects(effectSourceInstance)\n      )\n    );\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{}, ] },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: EffectsRootModule, },\n{type: Array, decorators: [{ type: Inject, args: [FEATURE_EFFECTS, ] }, ]},\n{type: StoreModule, decorators: [{ type: Optional }, ]},\n];\n}\n\nfunction EffectsFeatureModule_tsickle_Closure_declarations() {\n/** @type {?} */\nEffectsFeatureModule.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nEffectsFeatureModule.ctorParameters;\n/** @type {?} */\nEffectsFeatureModule.prototype.root;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}